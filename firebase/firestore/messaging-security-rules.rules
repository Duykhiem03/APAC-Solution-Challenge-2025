// Firestore security rules for message delivery status updates
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }
    
    function isUserInConversation(conversationId) {
      let conversation = get(/databases/$(database)/documents/conversations/$(conversationId));
      return isSignedIn() && conversation != null && request.auth.uid in conversation.data.participants;
    }
    
    // Messages collection
    match /messages/{messageId} {
      // Allow read if the user is a participant in the conversation
      allow read: if isSignedIn() && isUserInConversation(resource.data.conversationId);
      
      // Allow create if the user is a participant in the conversation
      allow create: if isSignedIn() && isUserInConversation(request.resource.data.conversationId) && 
                      request.resource.data.sender == request.auth.uid;
      
      // Allow updates only to specific fields for delivery status management
      allow update: if isSignedIn() && (
        // Allow the sender to update any field
        (resource.data.sender == request.auth.uid) ||
        
        // Allow participants to update only read-related fields
        (
          isUserInConversation(resource.data.conversationId) && 
          request.resource.data.diff(resource.data).affectedKeys()
              .hasOnly(['read', 'readBy', 'deliveryStatus']) &&
          (
            // Only allow specific status progressions
            !("deliveryStatus" in request.resource.data.diff(resource.data).affectedKeys()) ||
            (
              resource.data.deliveryStatus == "SENDING" && request.resource.data.deliveryStatus in ["SENT", "DELIVERED", "READ"] ||
              resource.data.deliveryStatus == "SENT" && request.resource.data.deliveryStatus in ["DELIVERED", "READ"] ||
              resource.data.deliveryStatus == "DELIVERED" && request.resource.data.deliveryStatus == "READ"
            )
          )
        )
      );
      
      // Only allow delete if the user is the sender
      allow delete: if isSignedIn() && resource.data.sender == request.auth.uid;
    }
    
    // Conversations collection
    match /conversations/{conversationId} {
      // Allow read if the user is a participant
      allow read: if isSignedIn() && request.auth.uid in resource.data.participants;
      
      // Allow create if the user includes themselves as a participant
      allow create: if isSignedIn() && request.auth.uid in request.resource.data.participants;
      
      // Allow updates if the user is a participant
      allow update: if isSignedIn() && request.auth.uid in resource.data.participants;
      
      // Only allow delete if all participants agree (not implemented currently)
      allow delete: if false;
    }
    
    // User status collection for online status
    match /userStatus/{userId} {
      // Users can only write their own status
      allow write: if isSignedIn() && request.auth.uid == userId;
      
      // Anyone can read status (could be restricted to contacts)
      allow read: if isSignedIn();
    }
    
    // Typing status collection
    match /typing/{typingId} {
      // Format: "conversationId_userId"
      allow read: if isSignedIn() && 
                    typingId.split("_").size() == 2 && 
                    isUserInConversation(typingId.split("_")[0]);
      
      // Users can only update their own typing status
      allow write: if isSignedIn() && 
                     typingId.split("_").size() == 2 && 
                     typingId.split("_")[1] == request.auth.uid &&
                     isUserInConversation(typingId.split("_")[0]);
    }
    
    // User FCM tokens for notifications
    match /userFcmTokens/{tokenId} {
      // Users can only manage their own tokens
      allow read, write: if isSignedIn() && tokenId.matches(request.auth.uid + '_.*');
      
      // For delivery receipts, allow checking if token exists
      allow get: if isSignedIn();
    }
    
    // User chats metadata (unread counts, etc.)
    match /userChats/{userId} {
      // Users can only access their own chat metadata
      allow read, write: if isSignedIn() && userId == request.auth.uid;
    }
  }
}